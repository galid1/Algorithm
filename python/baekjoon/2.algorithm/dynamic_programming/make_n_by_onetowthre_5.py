# baekjoon 15990 1,2,3 더하기 5
# 이전 수를 반복해서 사용할 수 없는 경우를 체크 하기 위해 이차원 배열을 사용
# 예를들어 d[i][1]은 i를 만들기 위해 바로 이전에 1을 더한 경우이다.

# 조금 더 구체적으로 예를 들면 4를 만들기 위한 경우의 수를 구한다고 가정했을 때에는 아래와 같은 식이 생성된다
# 4 = d[4][1] + d[4][2] + d[4][3] // 4를 만들기 위한 경우는 (4를 만들기위해 이전에 1을 사용한 경우) + (이전에 2를 사용한 경우) + (이전에 3을 사용한 경우) 이다.

# 다시 d[4][1]은 다음과 같은 식으로 구할 수 있다
# d[4][1] = d[4 - 1][2] + d[4 - 1][3] // d[4][1]은 4를 만들기 위해 이전에 1을 사용한 경우 이므로 (3을 만들기 위해 2를 사용한 경우) + (3을 만들기 위해 1을 사용한 경우) 로 나타낼 수 있다.

import sys

def make_n(n):
    #초기화 , 예외처리
    d[1][1] = 1
    d[1][2] = 0
    d[1][3] = 0
    d[2][1] = 0
    d[2][2] = 1
    d[2][3] = 0
    d[3][1] = 1
    d[3][2] = 1
    d[3][3] = 1

    # 이미 존재하는 경우
    if d[n][1] > 0 and d[n][2] > 0 and d[n][3]:
        return (d[n][1] + d[n][2] + d[n][3])%1000000009

    # d[n][1], d[n][2], d[n][3] 구하기
    for j in range(4, n+1):
        d[j][1] = (d[j - 1][2] + d[j - 1][3])%1000000009
        d[j][2] = (d[j - 2][1] + d[j - 2][3])%1000000009
        d[j][3] = (d[j - 3][1] + d[j - 3][2])%1000000009

    return (d[n][1] + d[n][2] + d[n][3])%1000000009


d = [[0 for i in range(4)] for i in range(100000 + 1)]
test_case = int(sys.stdin.readline())
results = []
for i in range(test_case):
    results.append(make_n(int(sys.stdin.readline())))

for result in results:
    print(result)